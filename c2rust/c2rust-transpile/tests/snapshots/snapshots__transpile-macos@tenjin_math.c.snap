---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/os-specific/tenjin_math.macos.rs
input_file: c2rust-transpile/tests/snapshots/os-specific/tenjin_math.c
---
#![allow(
    dead_code,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
use ::std::process::ExitCode;
extern "C" {
    fn acosf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn asinf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn atanf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn atan2f(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn cosf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn sinf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn tanf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn acoshf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn asinhf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn atanhf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn coshf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn sinhf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn tanhf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn expf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn exp2f(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn expm1f(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn logf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn log10f(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn log2f(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn log1pf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn modff(_: ::core::ffi::c_float, _: *mut ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn ldexpf(_: ::core::ffi::c_float, _: ::core::ffi::c_int) -> ::core::ffi::c_float;
    fn frexpf(_: ::core::ffi::c_float, _: *mut ::core::ffi::c_int) -> ::core::ffi::c_float;
    fn fabsf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn cbrtf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn hypotf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn powf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn sqrtf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn ceilf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn floorf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn nearbyintf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn rintf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn roundf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn truncf(_: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn fmodf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn remainderf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn copysignf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn nextafterf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn fdimf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn fmaxf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn fminf(_: ::core::ffi::c_float, _: ::core::ffi::c_float) -> ::core::ffi::c_float;
    fn printf(_: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" fn test_basic(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.abs();
    y += x % 3.5f32;
    y += remainderf(x, 2.0f32);
    return y;
}
unsafe extern "C" fn test_exp_log(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.exp();
    y += x.exp2();
    y += x.exp_m1();
    y += (x.abs() + 1.0f32).ln();
    y += (x.abs() + 1.0f32).log10();
    y += x.abs().ln_1p();
    y += (x.abs() + 1.0f32).log2();
    return y;
}
unsafe extern "C" fn test_pow_root(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.powf(2.0f32);
    y += x.abs().sqrt();
    y += x.cbrt();
    y += x.hypot(2.0f32);
    return y;
}
unsafe extern "C" fn test_trig(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.sin();
    y += x.cos();
    y += x.tan();
    y += x.min(1.0f32).max(-1.0f32).asin();
    y += x.min(1.0f32).max(-1.0f32).acos();
    y += x.atan();
    y += x.atan2(1.0f32);
    return y;
}
unsafe extern "C" fn test_hyperbolic(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.sinh();
    y += x.cosh();
    y += x.tanh();
    y += x.asinh();
    y += (x.abs() + 1.0f32).acosh();
    y += x.min(0.999f32).max(-0.999f32).atanh();
    return y;
}
unsafe extern "C" fn test_nearby(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.ceil();
    y += x.floor();
    y += x.trunc();
    y += x.round();
    y += nearbyintf(x);
    y += rintf(x);
    return y;
}
unsafe extern "C" fn test_remainder_classify(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut y: ::core::ffi::c_float = 0.0f32;
    y += x.copysign(-1.0f32);
    y += nextafterf(x, 2.0f32);
    y += fdimf(x, 1.0f32);
    y += x.max(1.0f32);
    y += x.min(1.0f32);
    return y;
}
unsafe extern "C" fn test_modf_split(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut ipart: ::core::ffi::c_float = 0.;
    let mut frac: ::core::ffi::c_float = modff(x, &mut ipart);
    return ipart + frac;
}
unsafe extern "C" fn test_frexp_ldexp(mut x: ::core::ffi::c_float) -> ::core::ffi::c_float {
    let mut exp: ::core::ffi::c_int = 0;
    let mut mant: ::core::ffi::c_float = frexpf(x, &mut exp);
    return ldexpf(mant, exp);
}
unsafe fn main_0() -> ::core::ffi::c_int {
    let mut x: ::core::ffi::c_float = 0.75f32;
    let mut sum: ::core::ffi::c_float = 0.0f32;
    sum += test_basic(x);
    sum += test_exp_log(x);
    sum += test_pow_root(x);
    sum += test_trig(x);
    sum += test_hyperbolic(x);
    sum += test_nearby(x);
    sum += test_remainder_classify(x);
    sum += test_modf_split(x);
    sum += test_frexp_ldexp(x);
    println!(
        "math.h smoke test checksum: {:.6}",
        sum as ::core::ffi::c_double as f64
    );
    return 0 as ::core::ffi::c_int;
}
pub fn main() -> ExitCode {
    unsafe { ExitCode::from(main_0() as u8) }
}
